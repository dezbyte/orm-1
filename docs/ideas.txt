
 Idea's
--------

defaultValues optie wegwerken en vervangen met ignoreUnknownColumns (aka voer een property_exists() uit voordat je de value insteld)
ignoreExtraColumns requires/implies skipValidation


recordValidatie voor elke RecordSelection 1x uitvoeren. OOK als het record valide is met de find() optie.
Hiervoor moet Record->validateRecord() aangepast worden.
validateRecord inlinen in de __construct.


Waar controleren of de kolommen in de database overeenkomen met de eigenschappen in het object?
 Issues:
 * Na de __construct() in static mode zijn alle eigenschappen weg.
   * De get_class_vars() geeft de protected eigenschappen (die wel beschijfbaar zijn door de parent) niet weer.
 * De $options['values'] kan een selectie van de kolommen zijn (via de RecordCollection)
 * IMPLENTED: Hoe exclude je een column van de $record->_columns. Ah. dat kan via een $db->tableInfo() en unset() op de kolommen die ongewenst zijn. (blacklisten lijkt mij beter dan whitelisten)
 * FALSE: De validate geld voor de class, niet de objecten, Het zou zonde zijn als de check voor elk object wordt uitgevoerd en de dump() zou vervuilen met deze
   * (maar) de find() en __construct(id) moeten detecteren of het record gevalideerd moet worden.
 * FALSE: De SimpleRecord class hoeft niet gecontroleerd te worden.

Huidige (niet optimale) oplossing:
In de constructor de eigenschappen (eenmalig) schrijven naar een globale variable: $GLOBALS['_recordValidations'][recordClass]
validateRecord() deze controleerd mapping tussen de kolommen en de eigenschappen.
Lokale (public of protected) waarden (die niet met een "_"beginnen)  moeten expliciet vermeld worden in een exclude lijst


Read-only records
  Workaround: Gebruik de ObjectView met de defaultFilter op false
ObjectView herschrijven met Filter objecten en hernoemen naar ObjectWrapper
ListView wordt IteratorWrapper en API herschrijven zodat:
$iteratorWrapper = new IteratorWrapper(view); of new IteratorWrapper(complextypes, filters);
$iteratorWrapper->setData($realIterator);


The "new Record(id)" problem:
  Because the "new" keyword will always create a new instance there can be multiple instances for the same record.
  This is incompatible with the Repositories view (1 record == 1 instance).

  Solution:
    When a second (or third, etc) "new" is used, remove _all_ properties and connect them with the "real" instance via __get() & __set()

 AFGEKEURDE IDEEEN
-------------------

Een Record is een singleton
 Customer(1) zit maar 1x in het geheugen.
 Pas je 1 object aan, dan pas je deze over de hele applicatie aan.
Afgekeurd omdat: Memoryhog + complex code is vervelender dan een paar extra queries.

De previousValues (huidige database waarden) buiten het object bewaren.
  Als je dan dezelfde wijziging uitvoerd wordt er maar 1 UPDATE query gegenereerd.
  Als je 1 instance wijzigd en een ander niet dat de code:
    $changed->save();
    $notChanged->save();
  De database hersteld naar de $notChanged state, maar
    $notChanged->save();
    $changed->save();

  Een voordeel is dat je voor het 2x openen de database niet nodig hebt.
  Alle geopende hasOne's worden nu ook gesaved, dit is een probleem.
Afgekeurd omdat: Uber Complex en Onverwacht systeem gedrag.
  Je verwacht dat $record->getChanges() de wijzigingen zijn aan die instancie.
  Niet de verschillen tussen de properties en de database toestand.


De Collection objecten verzorgen de database handelingen.
    Dus ook de find en save functies. Hierdoor hoeft een record de dbLink alleen maar door tegeven aan de Collection
    Nadelen de dump($record) wordt vervuild
Afgekeurd omdat: Levert extra code en onnodige tight coupling op, zonder grote meerwaarde (ipv een dbLink heb je een collectionLink).